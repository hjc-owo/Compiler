# 代码优化设计

我所做的优化只有循环结构优化、运算强度削弱（乘除优化）、计算常量表达式和分支跳转优化，下面对这几个优化作出说明。

## 循环结构优化

考虑下面的循环结构（使用 LLVM IR 的 BasicBlock 的概念来描述）：

```c
while (judgeBlock) {
    whileBlock;
}
whileFinalBlock;
```

显然直观的翻译应该是：

```llvm
judgeBlock:
    ... // 判断
    br * whileBlock whileFinalBlock

whileBlock:
    // do something
    br judgeBlock

whileFinalBlock:
    ...
```

如果是这样做，对于一个 $n$ 次循环，很显然一个 while 语句需要执行 $n$ 次分支和 $n$ 次跳转，但如果先将 while 语句转成 do-while 语句，则可以翻译成如下形式：

```llvm
judgeBlock:
    ... // 判断
    br * whileBlock whileFinalBlock

whileBlock:
    // do something
    ... // 判断
    br * whileBlock whileFinalBlock

whileFinalBlock:
    ...
```

这样对于一个执行了 $n$ 次的循环，就只需执行 $n$ 次分支，原本需经过 $2n+1$ 次跳转，优化后只需 $n+1$ 次跳转即可实现。

## 运算强度削弱

### 乘法优化

如果乘数其中有一个是常数的时候，就可以使用乘法优化，即若需要计算 $a \times b$，其中 $b$ 是常数，令 $d = \abs{b}$

- 如果 $d = 0$，那就直接不用算，直接得到结果 $p = 0$
- 如果 $d = \pm 1$，那也不用算，直接令 $p = a$
- 如果 $d = 2^k$，那就直接计算 $p = a << k$
- 如果 $d = 2^k + 1$，那就直接计算 $p = (a << k) + a$
- 如果 $d = 2^k - 1$，那就直接计算 $p = (a << k) - a$

如果 $b > 0$，那最后的结果就是 $p$；如果 $b < 0$，那最后的结果就是 $-p$

如果不满足上面的任意一种情况，那就只能直接计算 $a \times b$

例如

```c
a * 4 = a << 2
a * 5 = a << 2 + 1
a * -7 = -((a << 3) - a)
```

### 除法优化

当除数是常数的时候，可以做除法优化

```c
a / 64 = ((a >> 31) >>> 26 + a) >>> 6
a / 2021 = (a + ((0x3320550555 * a) >>> 32) >> 10) + (a < 0)
```

可以参考 Torbjörn Granlund and Peter L. Montgomery. 1994. Division by invariant integers using multiplication. SIGPLAN Not. 29, 6 (June 1994), 61–72. https://dl.acm.org/doi/10.1145/773473.178249

## 计算常量表达式

考虑下面的例子

```c
int i = -+-+-+-+-(2 + (4 + 5) * 7) / 6 - 5;
```

直接生成的 LLVM IR 中间代码如下所示：

```llvm
%1 = add i32 4, 5
%2 = mul i32 %1, 7
%3 = add i32 2, %2
%4 = sub i32 0, %3
%5 = sub i32 0, %4
%6 = sub i32 0, %5
%7 = sub i32 0, %6
%8 = sub i32 0, %7
%9 = sdiv i32 %8, 6
%10 = sub i32 %9, 5
%11 = alloca i32
store i32 %10, i32* %11
```

经过简单的简化之后，可以直接得到常量计算结果

```llvm
%1 = alloca i32
store i32 -15, i32* %1
```

其实做起来也很简单，只需要对每一条指令进行遍历，如果有可以计算的常量，那就直接把结果计算出来，然后全部替换，直到没有任何一条指令操作数全是常数为止，然后重新标号。

上面的例子当中，第一条指令是`%1 = add i32 4, 5`，那就计算 $4 + 5 = 9$，把所有的 `%1` 都换成 9，一直重复，直到最后得到结果 `%10 = -15`：

```llvm
%11 = alloca i32
store i32 -15, i32* %11
```

然后重新标号，得到最后的结果。

## 分支跳转优化

在前面的设计当中，我们已经在 BasicBlock 设计了前驱后继基本块的列表，后面的工作也比较简单。

- 一个基本块里只有一个无条件跳转的语句，考虑下面的场景：

  ```llvm
  basicBlock1:
      br basicBlock2
  ```

  那么就完全可以把所有跳转到 basicBlock1 的跳转语句改成跳转到 basicBlock2。

- 然后考虑无条件跳转，假设基本块 $b_1$ 可以无条件跳转到基本块 $b_2$，而 $b_2$ 的前驱列表只有 $b_1$，那就把这俩基本块合并。

- 如果有条件判断的判断内容是常数，考虑下面的情况：

  ```c
  int main() {
      if (1 < 2) {
          printf("1");
      }
      return 0;
  }
  ```

  如果不考虑优化，那么这里生成的 LLVM IR 源代码应该是

  ```llvm
  declare void @putch(i32)
  define dso_local i32 @main(){
  ;<label>:0:
      %1 = icmp slt i32 1, 2
      br i1 %1, label %2, label %3
  
  ;<label>:2:
      call void @putch(i32 49)
      br label %3
  
  ;<label>:3:
      ret i32 0
  }
  ```
  
  我们很明显的看出来，$1 < 2$ 恒成立，所以这句话肯定会被输出。这里出现了不必要的判断。因为要判断的内容是常数，我们就可以直接计算结果。优化后的 LLVM IR 代码如下：

  ```llvm
  declare void @putch(i32)
  define dso_local i32 @main(){
  ;<label>:0:
      call void @putch(i32 49)
      ret i32 0
  }
  ```
  
  这样就简化了不必要的分支跳转。
  
- 删除不会到达的基本块，遍历所有的基本块，如果这个基本块的前驱列表为空，那么就说明这个基本块不可能到达，可以直接删除。

一直做这四步操作，直到所有的基本块都不再变化为止。

经过这四步操作，就可以删除无用基本块，分支跳转更加优化。
