---
title: 错误处理
date: 2022-10-22 00:52:53
updated:
tags: compiler
categories:
keywords: compiler
description:
top_img: https://raw.githubusercontent.com/hjc-owo/hjc-owo.github.io/img/202210221026349.png
comments:
cover: https://raw.githubusercontent.com/hjc-owo/hjc-owo.github.io/img/202210221026349.png
toc: true
toc_number:
toc_style_simple:
copyright:
copyright_author: 花开一季 叶落一地
copyright_author_href: https://github.com/hjc-owo
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 错误处理设计

## 错误处理综述

错误处理作业包含了对某些错误的判断与输出，同时需要设计符号表并创建。

## 错误处理文件结构

只展示相关的文件和文件夹。

```
.
├── error
│   ├── Error.java
│   ├── ErrorHandler.java
│   └── ErrorType.java
└── symbol
    ├── ArraySymbol.java
    ├── FuncParam.java
    ├── FuncSymbol.java
    ├── FuncType.java
    └── Symbol.java
```

## `error`文件夹

包含了`Error`、`ErrorHandler`和`ErrorType`三个类。

很显然`ErrorType`当中的内容就是一个枚举。

```java
public enum ErrorType {
    a, b, c, d, e, f, g, h, i, j, k, l, m
}
```

`Error`的属性有错误类型`ErrorType`和错误出现的行数，考虑到每一行只有一个错误，我们就使用`equals`比较函数。

```java
public boolean equals(Error o) {
    return lineNumber == o.lineNumber;
}
```

在`ErrorHandler`当中处理错误列表以及遍历一次语法树找错误。

```java
public static List<Error> errors = new ArrayList<>();

public static void addError(Error newError) {
    for (Error error : errors) {
        if (error.equals(newError)) {
            return;
        }
    }
    errors.add(newError);
}

...
```

添加错误时，只需调用`addError()`方法，会判断是否（行数）相等，如果相等就不添加。

对于错误的输出，我们在`Error`当中添加了`compareTo`方法

```java
public int compareTo(Error o) {
    if (lineNumber == o.lineNumber) {
        return 0;
    } else if (lineNumber < o.lineNumber) {
        return -1;
    }
    return 1;
}
```

在`ErrorHandler`当中输出列表的时候，只要先`errors.sort(Error::compareTo);`即可。

## `Symbol`

考虑到每个`symbol`都有名字这个属性，所以将其拿出来，放在`Symbol`类里。

目前将`symbol`分为两种：`ArraySymbol`和`FuncSymbol`，前者是数组类型（包括普通变量、常量），后者是函数类型，都继承了`symbol`类。

`ArraySymbol`比较简单有是否是常量和数组维数两个属性。

```java
public class ArraySymbol extends Symbol {
    private boolean isConst; // 是否是常量
    private int dimension; // 0 变量，1 数组，2 二维数组
}
```

而`FuncSymbol`相对来说就比较复杂，每个`FuncSymbol`有返回类型和函数形参表两个属性。

```java
public class FuncSymbol extends Symbol { // 函数符号
    private FuncType type; // 函数返回类型，枚举，有VOID和INT两种情况
    private List<FuncParam> funcParams; // 函数参数表
}
```

## 符号表系统设计

错误处理这个地方的符号表，我们就直接放在`ErrorHandler`当中，是一个栈式符号表。

```java
private List<Triple<Map<String, Symbol>, Boolean, FuncType>> symbolTables;
```

栈当中的每一个元素是一个 Triple，表示一个基本块的符号表。

- Triple 的第一个元素是一个 Map
  - Map 的 key 是字符串
  - Map 的 value 是 Symbol
  - 表示字符串到符号的映射，在查找字符串的时候有帮助
- Triple 的第二个元素是一个 Boolean，表示这个基本块是否是函数的最外层基本块（需要考虑返回值的时候使用）
- Triple 的第三个元素是一个 FuncType，表示如果是函数的基本块，那么函数是否有返回值

当我们需要添加新的基本块符号表时，只需要`symbolTables.add(new Triple<>(new HashMap<>(), isFunc, funcType))`即可。

查找当前的基本块符号表也很简单，只需要`symbolTables.get(symbolTables.size() - 1)`即可。

比如，需要查找是否在当前的基本块符号表里，`symbolTables.get(symbolTables.size() - 1).getFirst().containsKey(ident)`。

需要查找是否声明过，只需要从`symbolTables.size() - 1`到`0`遍历一遍，如果能查到就是声明过可以用。

## 每种类型的错误的处理

- a 类错误 - 非法符号

  a 类错误比较简单，是判断字符串当中是否含有非法字符结构，直接在词法分析字符串时处理即可。判断的部分如下所示。

  ```java
  if (d == 32 || d == 33 || d >= 40 && d <= 126) {
      if (d == 92 && content.charAt(j + 1) != 'n') {
          ErrorHandler.getInstance().addError(new Error(lineNumber, ErrorType.a));
      }
  } else if (d == 37) {
      if (content.charAt(j + 1) != 'd') {
          ErrorHandler.getInstance().addError(new Error(lineNumber, ErrorType.a));
      }
  } else {
      ErrorHandler.getInstance().addError(new Error(lineNumber, ErrorType.a));
  }
  ```

- b 类错误 - 名字重定义

  对于题目给出的四条文法，在填写`<ident>`的时候，判断是否在当前符号表，也就是调用`containsInCurrent()`，如果在，那就报错。
  
- c 类错误 - 未定义的名字

  对于题目给出的三条文法，在符号表当中查找`<ident>`的时候，判断是否在符号表，也就是调用`contains()`，如果不在，那就报错。
  
- d 类错误 - 函数参数个数不匹配

  对于题目给出的文法，在符号表当中查找名字叫做`<ident>`的函数，得到其形参个数，获取这条文法`funcRParamsNode`的`expNodes`的`size()`，两者比较，如果不同，那就报错。

- e 类错误 - 函数参数类型不匹配

  这种类型的错误较为复杂，不过只需要考虑类型的错误，无非三种：整型、一维数组、二维数组。

  对于函数形参，在符号表当中查找到名字叫做`<ident>`的函数，然后遍历其形参，获取其形参类型，放到列表当中。

  对于调用时给的函数实参，当然也是遍历，如果是`<ident>`那就去符号表查找类型，如果只是数字的话，那就可以直接确定是整型。但是在这里要注意一点，比如实参是`p[1]`，同时`p = a[0]`，同时`a`确实是一个二维数组，这种也是语义正确的。我这里的解决方法是：用符号表查到的维数减去实参又带的维数，比如上面查到`p`的维数是 1，然后实参是`p[0]`，那就再减 1，所以真正的维数是 0。

- f 类错误 - 无返回值的函数存在不匹配的`return`语句

  对于题目给出的文法，只需要在`stmt`的类型是`Return`时，判断当前是不是在函数当中（表现为从`symbolTables.size() - 1`到`0`遍历一遍，如果存在某个基本块符号表的第二个元素是`true`，则在函数当中），如果在函数当中，但是`expNode != null`，那就报错。

- g 类错误 - 有返回值的函数缺少`return`语句

  g 类错误在`BlockNode`当中处理比较方便。当前在函数当中，并且函数的`FuncType`是`INT`，同时当前`blockNode`有最后一条语句，并且最后一条语句是`return`语句即可，否则报错。

- h 类错误 - 不能改变常量的值

  对于题目给出的文法，只需要判断`<LVal>`当中的`<ident>`是否是常量即可，如果是，那就报错。

- i j k 类错误 - 缺少分号、缺少右小括号')'、缺少右中括号']'

  这三者，在语法分析部分处理即可。这里提供一种方案，在需要配对常量符号（比如逗号、分号、各种括号）的时候，都调用`match()`函数。现在的`match()`函数在语法分析的基础上进行了一些修改，可以处理这三种类型的错误。并且为了防止影响到后面的语法分析、填写符号表等部分，如果发生缺失，那就补一个`token`。

  ```java
  private Token match(TokenType tokenType) {
      if (now.getType() == tokenType) {
          ...
      } else if (tokenType == TokenType.SEMICN) {
          ErrorHandler.getInstance().addError(new Error(tokens.get(index - 1).getLineNumber(), ErrorType.i));
          return new Token(TokenType.SEMICN, tokens.get(index - 1).getLineNumber(), ";");
      } else if (tokenType == TokenType.RPARENT) {
          ErrorHandler.getInstance().addError(new Error(tokens.get(index - 1).getLineNumber(), ErrorType.j));
          return new Token(TokenType.RPARENT, tokens.get(index - 1).getLineNumber(), ")");
      } else if (tokenType == TokenType.RBRACK) {
          ErrorHandler.getInstance().addError(new Error(tokens.get(index - 1).getLineNumber(), ErrorType.k));
          return new Token(TokenType.RBRACK, tokens.get(index - 1).getLineNumber(), "]");
      } else {
          throw new RuntimeException("Syntax error at line " + now.getLineNumber() + ": " + now.getContent() + " is not " + tokenType);
      }
  }
  ```
  
- l 类错误 - `printf` 中格式字符与表达式个数不匹配

  对于题目给出的文法，只需要在 `stmt` 的类型是 `Printf` 时，对 `FormatString` 当中的 `%d` 计数，然后和后面 `expNode` 的数量进行比较，如果不相同，那就报错。

- m 类错误 - 在非循环块中使用 `break` 和 `continue` 语句

  全局维护一个 `loopCount`，初始为 0，每次进入循环就加一，退出循环就减一。

  对于题目给出的文法，只需要在 `stmt` 的类型是 `Break` 或者 `Continue` 时，判断当前的 `loopCount` 是否为零即可，如果是，那就报错。
